###Note: This is a major release--a potentially breaking change.

This release of ScalaJack introduces two key improvements.

* Changed ScalaJack's read() and render() call signature--reversed hint and ext parameters
* Separation of Mongo dependencies
* Type hints can be anywhere in the JSON

### Reversed hint/exp parameters for ScalaJack.read() and ScalaJack.render()
Be careful with this one!  It's a trivial change but will break compiles.  This was changed because
in practice modifying the type hint seems to happen more frequently (for many projects) than defining extended
JSON rendering.  A little painful for those with existingn code bases perhaps, but an improvement going forward.  
With the other big changes in this release breaking things anyway it was felt this was a good time to do some
housecleaning.

### Separation of Mongo
From its inception ScalaJack has included MongoDB serialization support.  There may be times when you want JSON serialization without having to include Casbah/Mongo drivers if Mongo isn't part of your particular application so now Mongo support has been separated into its own package that you include with:

```scala
imclude co.blocke.scalajack._
include mongo._
```

The other ScalaJack functions like readDB() and renderDB() are still present and you use them as before.

THis design pattern also leaves oopen the door for other JSON-related specializations w/o creating bloat in the core ScalaJack code.

### Type hints in any order
ScalaJack has a powerful ability to serialize traits, utilizing a type hint in the JSON to know what object to materialize when the object
is read back in (as JSON).

Up to now the type hint (defaults to "_hint", but is settable), must be the first element
in the object's JSON, so this works:

```scala
{"_hint":"me.com.Foo","name":"Fred",...}
```

but this doesn't:

```scala
{"name":"Fred","_hint":"me.com.Foo",...}
```

The problem with this is that JSON officially has no field ordering, and while
JSON generated by ScalaJack follows this convention you can't control 3rd party JSON.

This limitation existed because the parser had to know how to parse the rest of an object's fields.  Now version 3.0.0 fixes this shortcoming with the development of a handy JSON look-ahead parser so you can now put the hint anywhere in the object's JSON (as perhaps you'd expected anyway).