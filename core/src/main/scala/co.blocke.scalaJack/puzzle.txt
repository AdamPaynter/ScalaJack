trait Mid[X,Y] {
	x : X
	y : Y
}

trait Top[A,B,C] {
	a : Mid[A,C]
	b : Mid[B,A]
}

case class MyMid[T,U](x:U, y:T) extends Mid[U,T]

case class MyTop[M](a:Mid[M,Int], b:Mid[Boolean,M])
	extends Top[M, Boolean, Int]


Object:
MyTop(MyMid(9,”nine”), MyMid(“true”,true))

SJ.read[Top[String,Boolean,Int])(js)



Step 1: Inspect & Resolve Top
	SjTrait[Top,(A->SjPrimitive(String),B->SjPrimitive(Boolean),C->SjPrimitive(Int))]

Step 2: Parsing JS, Inspect MyTop
	SjCaseClassProxy(MyTop, (M), ((a,SjTraitProxy(Mid,(SjTypeSymbol(M),SjPrimitive(Int)))),
		(b,SjTraitProxy(Mid,(SjPrimitive(Bool),SjTypeSymbol(M)))))

<new> Step 3: Resolve type symbols against declared Trait (Top)
	SjCaseClass(MyTop, ((a,SjTrait(Mid,(SjPrimitive(String),SjPrimitive(Int)))),
		(b,SjTraitProxy(Mid,(SjPrimitive(Bool),SjPrimitive(String)))))

		Look at positional comparison of inferred actual (non-symbolic) prams to Top and introspect
		that against the static declaration of MyTop, resolving any type symbols (M) as you go.

Step 4: Rinse and repeat for inspecting